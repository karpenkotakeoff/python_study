# Вам дано описание наследования классов в следующем формате.
# <имя класса 1> : <имя класса 2> <имя класса 3> ... <имя класса k>
# Это означает, что класс 1 отнаследован от класса 2, класса 3, и т. д.
# Создавать классы не требуется.
# Мы просим вас промоделировать этот процесс, и понять существует ли путь от одного класса до другого.
# Формат входных данных
# В первой строке входных данных содержится целое число n - число классов.
# В следующих n строках содержится описание наследования классов. В i-й строке указано от каких
# классов наследуется i-й класс. Обратите внимание, что класс может ни от кого не наследоваться.
# Гарантируется, что класс не наследуется сам от себя (прямо или косвенно), что класс не наследуется
# явно от одного класса более одного раза.
# В следующей строке содержится число q - количество запросов.
# В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
# Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
# Формат выходных данных
# Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком
# класса 2, и "No", если не является.

struct = {}
res = []
n = int(input())


def dfs_recursive(graph, vertex, path):
    if vertex not in graph:
        return path
    else:
        path += [vertex]
        for neighbor in graph[vertex]:
            if neighbor not in path:
                path = dfs_recursive(graph, neighbor, path)
        return path


while n != 0:
    clases = input()
    if ":" not in clases:
        struct[clases] = []
    else:
        cla, lis = clases.split(" : ")
        struct[cla] = lis.split()
    n -= 1
q = int(input())
while q != 0:
    p1, p2 = input().split()
    r = dfs_recursive(struct, p2, path=[])
    if p1 in r:
        res.append("Yes")
    else:
        res.append("No")
    q -= 1
for i in res:
    print(i)
