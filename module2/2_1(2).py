# Вам дано описание наследования классов исключений в следующем формате.
# <имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
# Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
# Важное примечание:
# В отличие от предыдущей задачи, типы исключений не созданы.
# Создавать классы исключений также не требуется
# Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и
# не ловить, потому что мы уже ранее где-то поймали их предка.
#
# Формат входных данных
# В первой строке входных данных содержится целое число n - число классов исключений.
# В следующих n строках содержится описание наследования классов. В i-й строке
# указано от каких классов наследуется i-й класс. Обратите внимание, что класс
# может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от
# себя (прямо или косвенно), что класс не наследуется явно от одного класса более одного раза.
# В следующей строке содержится число m - количество обрабатываемых исключений.
# Следующие m строк содержат имена исключений в том порядке, в каком они были написаны у Антона в коде.
# Гарантируется, что никакое исключение не обрабатывается дважды.
#
# Формат выходных данных
# Выведите в отдельной строке имя каждого исключения, обработку которого можно удалить
# из кода, не изменив при этом поведение программы. Имена следует выводить в том же порядке, в
# котором они идут во входных данных.

checked = []
base = {}
res = []


def dfs_recursive(graph, vertex, path):
    if vertex not in graph:
        path += [vertex]
        return path
    else:
        path += [vertex]
        for child in graph[vertex]:
            if child not in path:
                dfs_recursive(graph, child, path)
        return path


# Ввод данных
n = int(input())
while n != 0:
    s = input().split()
    if len(s) > 1:
        if s[0] not in base:
            base[s[0]] = s[2:]
        else:
            base[s[0]] += s[2:]
    else:
        base[s[0]] = []
    n -= 1

m = int(input())
while m != 0:
    a = input().strip()
    if a in checked:
        res.append(a)
    checked.append(a)
    parens = []
    parens = dfs_recursive(base, a, parens)
    if len(set(checked) & set(parens[1:])) > 0:
        res.append(a)
    m -= 1
for i in res:
    print(i)

